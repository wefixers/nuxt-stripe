import type { StripeConstructorOptions } from '@stripe/stripe-js'
import { addImports, addTemplate, createResolver, defineNuxtModule, findPath, useLogger } from '@nuxt/kit'
import { startSubprocess } from '@nuxt/devtools-kit'
import { normalize, relative } from 'pathe'
import { joinURL } from 'ufo'
import defu from 'defu'

import { name, version } from '../package.json'

/**
 * Represents a set of options accessible on runtime with `useRuntimeConfig().public.stripe`.
 */
export interface ModulePublicRuntimeConfig {
  /**
   * The Stripe publishable key, it is intended to be exposed to the users.
   * Use `NUXT_PUBLIC_STRIPE_PUBLISHABLE_KEY` in the `.env` to set this key automatically.
   *
   * Check the official doc: {@link https://stripe.com/docs/keys#obtain-api-keys}
   */
  publishableKey: string

  /**
   * The Stripe client options.
   *
   * ### Note:
   * This object is available on the client-side, do not accidentally expose sensitive information.
   */
  client?: StripeConstructorOptions
}

export interface ModuleOptions extends ModulePublicRuntimeConfig {
  /**
   * The path to the stripe webhook, it will be auto-detected and the Stripe CLI will listed for events.
   * Set to `false` to disable this behavior.
   *
   * @default "api/stripe/webhook"
   */
  webhookPath?: string | false
}

export default defineNuxtModule<Partial<ModuleOptions>>({
  meta: {
    name,
    version,
    configKey: 'stripe',
  },
  defaults: {
    publishableKey: '',
  },
  async setup(options, nuxt) {
    const logger = useLogger(name)

    logger.info(`\`${name}\` setup...`)

    nuxt.options.runtimeConfig.public.stripe = defu(
      nuxt.options.runtimeConfig.public.stripe as any,
      {
        publishableKey: options.publishableKey,
        client: options.client,
      },
      {
        // This empty object removes null and undefined
      },
    )

    const resolver = createResolver(import.meta.url)

    addImports([
      {
        name: 'useStripe',
        from: resolver.resolve('./runtime/composables'),
      },
    ])

    const serverRuntime = resolver.resolve('./runtime/server/stripe')

    addTemplate({
      filename: 'types/stripe.d.ts',
      getContents: () => `// Generated by ${name} ${version}
declare module '#stripe' {
  export const defineStripeWebhook: typeof import('${serverRuntime}').defineStripeWebhook
}
`,
    })

    nuxt.hook('nitro:config', (nitroConfig) => {
      nitroConfig.alias = nitroConfig.alias || {}

      // Inline module runtime in Nitro bundle
      nitroConfig.externals = defu(
        typeof nitroConfig.externals === 'object' ? nitroConfig.externals : {},
        {
          inline: [resolver.resolve('./runtime')],
        },
      )

      nitroConfig.alias['#stripe'] = serverRuntime
    })

    nuxt.hook('prepare:types', (options) => {
      options.references.push({
        path: resolver.resolve(nuxt.options.buildDir, 'types/stripe.d.ts'),
      })
    })

    // run the stripe CLI only in development
    if (nuxt.options.dev && options.webhookPath !== false) {
      let stripeWebhookPath = await findPath(options.webhookPath || 'api/stripe/webhook', {
        cwd: nuxt.options.serverDir,
      })

      if (stripeWebhookPath) {
        stripeWebhookPath = normalize(relative(nuxt.options.serverDir, stripeWebhookPath))
        stripeWebhookPath = stripeWebhookPath.split('.')[0]
      }

      if (stripeWebhookPath) {
        const port = nuxt.options.devServer.port
        const webhookPath = joinURL(`localhost:${port}`, stripeWebhookPath!)

        startSubprocess(
          {
            command: 'stripe',
            // stripe listen --forward-to localhost:3000/api/stripe/webhook
            args: ['listen', '--forward-to', webhookPath],
          },
          {
            id: 'nuxt-stripe-cli',
            name: 'Stripe CLI',
            icon: 'simple-icons:stripe',
          },
          nuxt,
        )

        nuxt.hook('devtools:terminal:write', ({ id, data }) => {
          if (id === 'nuxt-stripe-cli') {
            logger.info(`> ${data}`)
          }
        })
      }
    }

    logger.success(`\`${name}\` setup done`)
  },
})
